/*
 Copyright (C) 2022-present Metahkg Contributors

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as
 published by the Free Software Foundation, either version 3 of the
 License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
// original template from https://github.com/cra-template/pwa/blob/main/packages/cra-template-pwa-typescript
/*
Copyright 2020 Google LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */

/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { CacheableResponsePlugin } from "workbox-cacheable-response";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate, NetworkFirst } from "workbox-strategies";
import { Notification } from "@metahkg/api";

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(
    // Return false to exempt requests from being fulfilled by index.html.
    ({ request, url }: { request: Request; url: URL }) => {
        // If this isn't a navigation, skip.
        if (request.mode !== "navigate") {
            return false;
        }

        // If this is a URL that starts with /_, skip.
        if (url.pathname.startsWith("/_")) {
            return false;
        }

        // If this looks like a URL for a resource, because it contains
        // a file extension, skip.
        if (fileExtensionRegexp.test(url.pathname)) {
            return false;
        }

        // Return true to signal that we want to use the handler.
        return true;
    },
    createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html"),
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
    // Add in any other file extensions or routing criteria as needed.
    ({ url }) =>
        url.origin === self.location.origin &&
        ["/static", "/images", "/favicon.ico"].some((path) =>
            url.pathname.startsWith(path),
        ),
    // Customize this strategy as needed, e.g., by changing to CacheFirst.
    new StaleWhileRevalidate({
        cacheName: "app-static",
        plugins: [
            // Ensure that once this runtime cache reaches a maximum size the
            // least-recently used files are removed.
            new ExpirationPlugin({ maxEntries: 500 }),
        ],
    }),
);

registerRoute(
    ({ url }) =>
        [
            "cdn.jsdelivr.net",
            "cdnjs.cloudflare.com",
            "static.cloudflareinsights.com",
            JSON.parse(localStorage.getItem("serverConfig") || "{}")?.domains?.images ||
                "i.metahkg.org",
            JSON.parse(localStorage.getItem("serverConfig") || "{}")?.domains?.rlpProxy ||
                "rlp.metahkg.org",
            "na.cx",
            "gstatic.com",
            "google.com",
            "youtube.com",
            "ytimg.com",
            "googlevideo.com",
        ].some((i) => url.origin.includes(i)),
    new StaleWhileRevalidate({
        cacheName: "app-external-assets",
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200],
            }),
            new ExpirationPlugin({ maxAgeSeconds: 60 * 24 * 60 }),
        ],
    }),
);

registerRoute(
    ({ url }) => url.pathname.startsWith("/api"),
    new NetworkFirst({
        cacheName: "app-api",
        plugins: [
            new CacheableResponsePlugin({
                statuses: [200],
            }),
        ],
    }),
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
    if (event.data && event.data.type === "SKIP_WAITING") {
        self.skipWaiting();
    }
    if (event.data && event.data.type === "CHECK_VERSION") {
        const build = process.env.REACT_APP_build || process.env.REACT_APP_date || "1";
        self.clients.matchAll({ includeUncontrolled: true, type: "window" }).then((all) =>
            all.map((client) =>
                client.postMessage({
                    type: "CURRENT_VERSION",
                    payload: `build ${build}`,
                }),
            ),
        );
    }
});

// Any other custom service worker logic can go here.

const DOMAIN = self.location.origin;

self.addEventListener("activate", async () => {
    // This will be called only once when the service worker is activated.
    try {
    } catch (err) {
        console.log("Error", err);
    }
});

self.addEventListener("push", (event) => {
    if (!event.data) return;
    const data: Notification = event.data.json();
    const promiseChain = self.registration
        .showNotification(data.title || "New notification", {
            ...data.options,
            icon: `${DOMAIN}/favicon.ico`,
        })
        .then(() => {
            console.log("push success");
        })
        .catch(() => {
            console.log("push fail");
        });
    event.waitUntil(promiseChain);
});

self.addEventListener("notificationclick", function (event) {
    event.preventDefault();

    if (event.action) {
        console.log(`Action clicked: '${event.action}'`);
    } else {
        console.log("Notification Click.");
        console.log(event.notification, event?.notification?.data);
    }

    const data = event?.notification?.data;
    console.log(data?.url);
    const promiseChain = self.clients.openWindow(data?.url || DOMAIN);
    // TODO: send read to server
    event.waitUntil(promiseChain);
});

self.addEventListener("notificationclose", function (event) {
    console.log("Notification Close.");

    // TODO: send read to server
    // const promiseChain = self.clients.openWindow(DOMAIN);
    // event.waitUntil(promiseChain);
});
